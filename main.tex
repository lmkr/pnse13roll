\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%

%\usepackage{a4wide}
\usepackage{url}
\pagestyle{plain}
%%%%%%%%%%%%%%%%%%%%
\input{commands}
%%%%%%%%%%%%%%%%%%%%

\title{Transforming Platform Independent CPN Models into Code for the TinyOS
  Platform: \\ A Case Study of the RPL Protocol}

%\title{
%  A Coloured Petri Net based Approach to Software Engineering for the
%  TinyOS Platform
%}

\author{
  Vegard Veiset \and Lars Michael Kristensen
}
\institute{
  Department of Computing, Bergen University College \\
  Email: \email{vegard.veiset@stud.hib.no,lmkr@hib.no}
}
%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle

\begin{abstract}

TinyOS is a widely used platform for the development of networked
embedded systems offering a programming model targeting resource
constrained devices. We present a software engineering approach where
Coloured Petri Net (CPNs) models are used as a starting point for
developing protocol software for the TinyOS platform. The approach
consists of five refinement steps where a platform-independent CPN
model is gradually refined into a platform-specific model that enables
automatic code generation. To evaluate our approach, we use it to
obtain an implementation of the IETF RPL routing protocol for sensor
networks.


\end{abstract}

\subsubsection{Introduction.} Model-based software engineering and verification  has several attractive properties in the development of flexible and reliable
software systems. In order to fully leverage the modelling investment
it is desireable to use the constructed models also for the
implementation of the software on the platform under
consideration. Coloured Petri Nets \cite{CPNsttt} (and Petri Nets in
general) constitute a general purpose modelling language supporting
platform-independent modelling of concurrent systems. Hence, in most
cases such models are too abstract to be used directly to implement
software. In order to bridge the gap between abstract and platform
independent CPN models and the implementation of software to be
deployed, a concept of \concept{pragmatics} were introduced in
\cite{NWPTpaper}. Pragmatics are syntactical annotations that can be
added to a CPN model and used to direct code generation for a specific
platform. The contribution of this paper is an approach
\cite{veisetthesis} that exploits pragmatics in combination with a
five step refinement methodology to enable code generation for the
TinyOS platform. Applications for TinyOS \cite{LevisTinyOS} are
implemented using the NesC programming language (a dialect of C) and
an event-based split-phase programming model. An application written
in NesC is organised into a wired set of modules each providing an
interface consisting of commands and events.


%A central
%aspect of the programming model is the use of tasks and a split-phase
%operations in order to avoid lengthly and time-consuming operations
%that would violate any real-time constraints.

\vspace*{-0.75em}
\subsubsection{Refinement Steps.}

The model refinement start from a platform independent CPN model
constructed typically with the aim of specifying the protocol
operation and performing model checking of the protocol design. Each
step consists of a transformation that uses the constructs of the CPN
modelling language to add details to the model. Furthermore, in each
step pragmatics are added that will direct the code generation
performed after the fifth step:


\begin{description}
\setlength{\itemsep}{0.3em}
%\setlength{\leftmargin}{0em}
%\setlength{\itemindent}{0em}

\item[Step 1: Component Architecture] consist of annotating CPN
  submodules and substitution transition corresponding to TinyOS
  components, and make explicit the interfaces used and provided by
  components.

\item[Step 2: Resolving Interface Conflicts] resolves interface
  conflicts allowing components to use multiple instances of an
  interface. This is done by annotating CPN arcs with information
  providing locally unique names.

\item[Step 3: Component and Interface Signature] adds type signatures
  to components and interfaces by creating explicit submodules for
  command and events, and by refining colour sets to reflect the
  interface signatures.

\item[Step 4: Component Classification] further refines the components
  by classifying them into four main types: timed, external, boot, and
  generic.

\item[Step 5: Internal Component Behaviour] consist of refining the
  modelling of the individual command and events such that control
  flow and data manipulation becomes explicit and organised into
  atomic statement blocks.

\end{description}

\noindent
After the fifth refinement step has been performed, the CPN model
includes sufficient detail to be used as a basis for automated code
generation.
 
\vspace*{-0.75em}
\subsubsection{The RPL Protocol and Code Generation.}

To evaluate our approach on an industrial-sized example, we have
conducted a case study based on the RPL routing protocol
\cite{rplprotocol} developed by the Internet Engineering Task
Force. The RPL protocol allows a set of sensor nodes to construct a
destination-oriented directed acyclic graph which can be used for
multi-hop communication among the sensor nodes.  To support the
automatic code generation for TinyOS, we have developed a software
prototype in Java that performs a template-based model-to-text
transformation on the models resulting from the fifth refinement
step. The software prototype relies on the Access/CPN framework
\cite{accesscpn} to load CPN models created with CPN Tools. The
prototype performs top-down traversal of the CPN model where code
templates are selected according to the pragmatic annotationson the
CPN model elements encountered.

% tool support

\ignore{
\paragraph{\textbf{Outlook}.}

At this stage a first proof-of-concept for our approach has been
established via the case study performed on the Roll protocol. This
case study will have to be complemented by additional
examples. Furthermore, at this stage the steps of the approach has
been introduced in an informal manner. Formally defining the
meta-models corresponding to each of the step would be required to
precisely specify the approach. Another direction is the application
of verification techniques at each step of the approach in order to
ensure that the key properties are preserved by the model
transformations performed at each step, and to also investigate
whether verification is appliable from the abstract to the refined
models.
}

\bibliographystyle{plain}
\bibliography{bib}

\end{document}
